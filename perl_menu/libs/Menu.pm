# Menu.pm
package Menu;
#################################################
# package Menu
# Version 2.01 AUGUST 2019 
# AUTHOR: Gustavo Mayordomo (83885613@es.ibm.com)
# GROUP:  Grupo Bases de datos torre 1
#  Package for menu appl common routines 
# ###############################################
# =============================================================================
# History of Changes
# =============================================================================
# Version   Person: /Comments
# 20190724  Gustavo Mayordomo : Created from Spanish version 1.17
# 20190814  Gustavo Mayordomo : Modify comments and code to English support
# =============================================================================

  BEGIN {
        require Exporter;

        # Version of the utility
        our $VERSION     = 1.18;

        # Heritage from Exporter to export functions and variables
        our @ISA         = qw(Exporter);

        # Predetermined functions and variables
        our @EXPORT = qw(existSubmenu existScript executeScript clear_screen clear_end gotoxy init finish hayDinamic resolDinamic sustDinamic $name copioMenu 
              imprime_color cambio_color);
      
    }

 
use strict;
use warnings;
use Arquitectura;
use POSIX;
use Term::Cap;
use Term::ANSIColor qw(:constants);

my $tcap="";
my $delay="";
my $maxrow="";
my $pdynam="";

my ($result);



##########################################################################
# Routine: copioMenu
# Input:  origMenu -> file source to copy
#         destMenu _> file target to copy
# Output: 1 if ok
# Routine to copy a file into other. Normally used to copy a dynamic menu
# resolved from a temporary file to the main one 
##########################################################################
sub copioMenu {

    my ($origMenu, $destMenu)  = @_;
 
    open(FILEIN, "< $origMenu")
    or die "Couldn't open File $origMenu   \n";

    open(FILEOUT, "> $destMenu")
    or die "Couldn't open File $destMenu   \n";

    my $line ="";
    my $result=1;
 
    while (defined ($line = <FILEIN>)) {
                          $line=trim($line);
                          if ( $line ne '' ) {
                                            print FILEOUT "$line \n";
                                              }    
                                       }

    close (FILEIN);
    close (FILEOUT);

    return ($result);

              }   


##########################################################################
# Routine: imprime_color
# Input:  color, text
#      
# Routine to print text input with the colour selected
##########################################################################
sub imprime_color {
  
    my ($color, $texto)  = @_;

    print $color, "$texto";  

  }


###########################################################################################
#  Routine: cambio_color
#  Input: color 
#
#  Routine to change default colour
###########################################################################################
sub cambio_color {
  
    my ($color)  = @_;

    print $color;  

  }

###########################################################################################
#  Routine: susDinamic
#  Input nameMenu (menu.ini), pdyname (dynamic menu), dir (directory)
#  Output result:  1 if ok
#
#  This routine delete the dinamic entry in the main menu file and replace it by its content
#  ( generated by Resoldinamic routine and located in temporal.txt file of dir directory) 
############################################################################################
sub sustDinamic

 {

    my ($nameMenu, $pdynam,$dir)  = @_; 

    my $tmpfich=$dir."temporal.txt";
    my $tmpMenu=$nameMenu.".aux";
    my $line="";
    my $lineaux="";
    my @tags=();
    my $name="";
    my $desc="";
    my $result=1;

    
    open(FILEIN, "< $nameMenu")
    or die "Couldn't open File $nameMenu   \n";

    open(AUXTMP, "< $tmpfich")
    or die "Couldn't open File $tmpfich   \n";

    open(OUTPUT, "> $tmpMenu")
    or die "Couldn't open File $tmpMenu   \n";

    while (defined ($line = <FILEIN>)) {

           if (index($line,$pdynam) != -1)
                 {
                      while (defined ($lineaux = <AUXTMP>)) {
                                  print OUTPUT "$lineaux";               
                                                            } 
                 } 
                else  {
                        print OUTPUT "$line";
                      }
                                        }
    close (FILEIN);
    close (AUXTMP);
    close (OUTPUT);

##  Copy over txt

    open(FILEIN, "< $tmpMenu")
    or die "Couldn't open File $tmpMenu   \n";

     open(OUTPUT, "> $nameMenu")
    or die "Couldn't open File $nameMenu   \n";

    while (defined ($line = <FILEIN>)) {
                          print OUTPUT "$line";
                                       }

    close (FILEIN);
    close (OUTPUT);



   return ($result); 
    
 }

###########################################################################################
#  Routine: resolDinamic
#  Input:  nameMenu (menu.ini), dir (directory)
#  Output: name_DYNAMIC value  
#          result:  1 if ok
#
#  This routine search for an _DYNAMIC entry in .ini file. If there is any then generate
#  a temporal.txt file in dir directory to be resolved later
############################################################################################
sub resolDinamic

  {

     my ($nameMenu,$dir)  = @_;
    
    my $line="";
    my @tags=();
    my $name="";
    my $desc="";
    my $comando="";  
    my $rc=0; 
    my $tmpMenu=$dir."temporal.txt";
 
    $result=1;

    open(FILEIN, "< $nameMenu")
    or die "Couldn't open File $nameMenu   \n";

    open(OUTPUT, "> $tmpMenu")
    or die "Couldn't open File $tmpMenu   \n";
 
     while (defined ($line = <FILEIN>)) {
  #  chomp $line;
    @tags = split('<TAG>', $line);
    $tags[0]=trim($tags[0]);  

           if ($tags[0] =~ m/_DYNAMIC/)
                                     {
                                     ($name,$desc,$comando)=split('<TAG>', $line);
                                     $comando=trim($comando);
                                     my $Cmd=$dir."Dynamic/$comando";
                                     my @CmdResult=`$Cmd`;  
                                     $rc=$?;
                                      if ($rc != 0){
                                            foreach $_ (@CmdResult) {
                                            print "$_ \n";
                                                                     } # END foreach
                                            close (FILEIN); 
                                            close (OUTPUT);
                                            $result=0;
                                            return ($result,"NULL");          
 
                                                    } # end bad command
                                         else {
                                             #  the command return a correct file
                                             ($name,$desc,$comando)=split('<TAG>', $line);
                                             $name=trim($name);
                                             my $menuTemp=$dir."menuTemp.txt";
                                             open(FILETMP, "< $menuTemp")
                                             or die "Couldn't open File $menuTemp   \n";
                                               my $lineaux="";
                                               $name =~ s/_DYNAMIC//g;
                                               $lineaux=$name."_START <TAG>".$desc."<TAG>\n";
                                               print OUTPUT "$lineaux";
                                               while (defined ($lineaux = <FILETMP>)) {
                                                                                        print OUTPUT "$lineaux";
                                                                                       }
                                               $lineaux=$name."_END <TAG>\n";
                                               print OUTPUT "$lineaux";
                                               close (FILETMP);
                                               $result=1;
                                               close (FILEIN);
                                               close (OUTPUT);
                                               $name=$name."_DYNAMIC";
                                               return ($result, $name);

                                             }   # find with else of correct command
                                     }  # end if dynamic  
  
                                      }  # while
   close (FILEIN); 
   close (OUTPUT);
   $name=$name."_DYNAMIC";
   return ($result, $name);


  }
###########################################################################################
#  Routine: hayDinamic
#  Input:  nameMenu (menu.ini)
#  Output: result:  1 if there is more dynamic entrys 0 otherwise
#
#  This routine search for an _DYNAMIC entry in nameMenu file. 
############################################################################################
sub hayDinamic
  
   {
     my ($nameMenu)  = @_;
    
    my $line="";
    my @tags=();
 
    $result=0;

    open(FILEDIN, "< $nameMenu")
    or die "Couldn't open File $nameMenu   \n";



    while (defined ($line = <FILEDIN>)) {
   # chomp $line;

    @tags = split('<TAG>', $line);
    $tags[0]=trim($tags[0]);  
       
           
           if ($tags[0] =~ m/_DYNAMIC/)
                                     {
                                     $result=1;
                                     close (FILEIN);
                                     return $result;
                                     }     
  
                                      }  # while
   close (FILEDIN); 
   return $result;
      
   
   }

###########################################################################################
#  Routine: existSubmenu
#  Input:  nameMenu (menu.ini), name Submenu
#  Output: result:  1 if there is a Submenu name in nameMenu file, 0 otherwise
#
#  This routine search for an menu entry in the file nameMenu 
############################################################################################
sub existSubmenu

{
    my ($nameMenu, $nameSubmenu)  = @_;
    
    my $line="";
    my @tags=();

    $nameSubmenu=$nameSubmenu.'_START';

    $result=0;
    
    open(FILEIN, "< $nameMenu")
    or die "Couldn't open File $nameMenu   \n";

    while (defined ($line = <FILEIN>)) {
    chomp $line;
    @tags = split('<TAG>', $line);
         $tags[0]=trim($tags[0]);   
         if ($tags[0] eq $nameSubmenu) {
                                     $result=1;
                                     close (FILEIN);
                                     return $result;
                                     }     
  
                                      }  # while
   close (FILEIN); 
   return $result;

    
}   

###########################################################################################
#  Routine: existScript
#  Input:  script, dir
#  Output: result:  1 if there is a program script in dir directory, 0 otherwise
#
#  This routine search for an script or pgme to execute in the dir directory 
############################################################################################
sub existScript

{
    my ($script,$dir)  = @_;
   
    $script = 'NULL' unless defined $script;    # asigno null si no esta inicializada
    $script=trim($script);
    $result=0;
    my $Cmd="ls $dir"."Scripts/";
    my @CmdResult=`$Cmd`;    

    foreach $_ (@CmdResult) {
                                 $_=trim($_);
                                  if ($script =~ m/$_/)
                                                       {
                                                        $result = 1;
                                                        }                                              
                              } # END foreach

    
   return $result;

    
}

###########################################################################################
#  Routine: executeScript
#  Input:  script, dir
#  Output: result:  1 if the execution of the script was ok
#
#  This routine execute the pgm script locate in directory dir  
############################################################################################
sub executeScript

{
    my ($script,$dir)  = @_;
    $script=trim($script);
    $result=1;
  
    clear_screen();   
 
    print " \n";
    cambio_color(CYAN);
    print " >>>>>>>> START SCRIPT EXECUTION  $script   <<<<<<<<<<<<<<<<<<<<\n";
    print " \n";
    cambio_color(WHITE);  

    my $Cmd=$dir."Scripts/$script &";
    my @CmdResult=`$Cmd`;

    foreach $_ (@CmdResult) {
                               print "$_ ";
                             } # END foreach

    cambio_color(CYAN);   
    print " \n";
    print " >>>>>>>> END  SCRIPT  EXECUTION  $script   <<<<<<<<<<<<<<<<<<<<\n";     

    
    
   return $result;

    
}



###########################################################################################
#  Routines: clear_screen,clear_end
# Two convenience functions.  clear_screen is obvious, and
# clear_end clears to the end of the screen.
###########################################################################################
sub clear_screen { $tcap->Tputs('cl', 1, *STDOUT) } 
sub clear_end    { $tcap->Tputs('cd', 1, *STDOUT) } 

###########################################################################################
#Routine gotoxy
# input x, y 
# Move the cursor to a particular location.
###########################################################################################
sub gotoxy {
    my($x, $y) = @_;
    $tcap->Tgoto('cm', $x, $y, *STDOUT);
} 

############################################################################################
# Routine init
# Get the terminal speed through the POSIX module and use that
# to initialize Term::Cap.
############################################################################################
sub init { 
    $| = 1;
    $delay = (shift() || 0) * 0.005;
    my $termios = POSIX::Termios->new();
    $termios->getattr;
    my $ospeed = $termios->getospeed;
    $tcap = Term::Cap->Tgetent ({ TERM => undef, OSPEED => $ospeed });
    $tcap->Trequire(qw(cl cm cd));
}
############################################################################################
#Routine finish  
# Clean up the screen.
############################################################################################
sub finish { 
    gotoxy(1, 1);
    clear_end();
}


END { }

1;
